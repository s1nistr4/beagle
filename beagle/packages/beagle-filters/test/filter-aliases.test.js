"use strict";const lex=require("beagle-lexer"),parse=require("beagle-parser"),handleFilters=require("../").handleFilters,customFilters={};test("filters can be aliased",()=>{const a=parse(lex("\nscript\n  :cdata:minify\n    function myFunc(foo) {\n      return foo;\n    }\n  ",{filename:__filename}),{filename:__filename,src:"\nscript\n  :cdata:minify\n    function myFunc(foo) {\n      return foo;\n    }\n  "}),b=handleFilters(a,customFilters,{},{minify:"uglify-js"});expect(b).toMatchSnapshot()}),test("we do not support chains of aliases",()=>{const a=parse(lex("\nscript\n  :cdata:minify-js\n    function myFunc(foo) {\n      return foo;\n    }\n  ",{filename:__filename}),{filename:__filename,src:"\nscript\n  :cdata:minify-js\n    function myFunc(foo) {\n      return foo;\n    }\n  "});try{handleFilters(a,customFilters,{},{"minify-js":"minify",minify:"uglify-js"})}catch(a){return void expect({code:a.code,message:a.message}).toMatchSnapshot()}throw new Error("Expected an exception")}),test("options are applied before aliases",()=>{const a=parse(lex("\nscript\n  :cdata:minify\n    function myFunc(foo) {\n      return foo;\n    }\n  :cdata:uglify-js\n    function myFunc(foo) {\n      return foo;\n    }\n  ",{filename:__filename}),{filename:__filename,src:"\nscript\n  :cdata:minify\n    function myFunc(foo) {\n      return foo;\n    }\n  :cdata:uglify-js\n    function myFunc(foo) {\n      return foo;\n    }\n  "}),b=handleFilters(a,customFilters,{minify:{output:{beautify:!0}}},{minify:"uglify-js"});expect(b).toMatchSnapshot()});