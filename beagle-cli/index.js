"use strict";var _fs=_interopRequireDefault(require("fs")),_path=_interopRequireDefault(require("path")),_commander=require("commander"),_mkdirp=require("mkdirp"),_chalk=_interopRequireDefault(require("chalk")),_pug=_interopRequireDefault(require("pug"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const basename=_path.default.basename;let dirname=_path.default.dirname,resolve=_path.default.resolve,normalize=_path.default.normalize,relative=_path.default.relative,options={};_commander.program.version("pug version: "+require("pug/package.json").version+"\npug-cli version: "+require("./package.json").version).usage("[options] [dir|file ...]").option("-O, --obj <str|path>","JSON/JavaScript options object or file").option("-o, --out <dir>","output the rendered HTML or compiled JavaScript to <dir>").option("-p, --path <path>","filename used to resolve includes").option("-b, --basedir <path>","path used as root directory to resolve absolute includes").option("-P, --pretty","compile pretty HTML output").option("-c, --client","compile function for client-side").option("-n, --name <str>","the name of the compiled template (requires --client)").option("-D, --no-debug","compile without debugging (smaller functions)").option("-w, --watch","watch files for changes and automatically re-render").option("-E, --extension <ext>","specify the output file extension").option("-s, --silent","do not output logs").option("--name-after-file","name the template after the last section of the file path (requires --client and overriden by --name)").option("--doctype <str>","specify the doctype on the command line (useful if it is not specified by the template)"),_commander.program.on("--help",function(){console.log("  Examples:"),console.log(""),console.log("    # Render all files in the `templates` directory:"),console.log("    $ pug templates"),console.log(""),console.log("    # Create {foo,bar}.html:"),console.log("    $ pug {foo,bar}.pug"),console.log(""),console.log("    # Using `pug` over standard input and output streams"),console.log("    $ pug < my.pug > my.html"),console.log("    $ echo 'h1 Pug!' | pug"),console.log(""),console.log("    # Render all files in `foo` and `bar` directories to `/tmp`:"),console.log("    $ pug foo bar --out /tmp"),console.log(""),console.log("    # Specify options through a string:"),console.log("    $ pug -O '{\"doctype\": \"html\"}' foo.pug"),console.log("    # or, using JavaScript instead of JSON"),console.log("    $ pug -O \"{doctype: 'html'}\" foo.pug"),console.log(""),console.log("    # Specify options through a file:"),console.log("    $ echo \"exports.doctype = 'html';\" > options.js"),console.log("    $ pug -O options.js foo.pug"),console.log("    # or, JSON works too"),console.log("    $ echo '{\"doctype\": \"html\"}' > options.json"),console.log("    $ pug -O options.json foo.pug"),console.log("")}),_commander.program.parse(process.argv),_commander.program.obj&&(options=parseObj(_commander.program.obj));/**
 * Parse object either in `input` or in the file called `input`. The latter is
 * searched first.
 */function parseObj(input){try{return require(_path.default.resolve(input))}catch(e){var str;try{str=_fs.default.readFileSync(_commander.program.obj,"utf8")}catch(a){str=_commander.program.obj}try{return JSON.parse(str)}catch(e){return eval("("+str+")")}}}[["path","filename"],// --path
["debug","compileDebug"],// --no-debug
["client","client"],// --client
["pretty","pretty"],// --pretty
["basedir","basedir"],// --basedir
["doctype","doctype"]// --doctype
].forEach(function(a){options[a[1]]=_commander.program[a[0]]===void 0?options[a[1]]:_commander.program[a[0]]}),"string"==typeof _commander.program.name&&(options.name=_commander.program.name);// --silent
var consoleLog=_commander.program.silent?function(){}:console.log,files=_commander.program.args,watchList={},render=_commander.program.watch?tryRender:renderFile;// left-over args are file paths
// object of reverse dependencies of a watched file, including itself if
// applicable
// function for rendering
// compile files
files.length?(consoleLog(),_commander.program.watch&&process.on("SIGINT",function(){process.exit(1)}),files.forEach(function(a){render(a)})):stdin();/**
 * Watch for changes on path
 *
 * Renders `base` if specified, otherwise renders `path`.
 */function watchFile(a,b,c){a=normalize(a);var d="  "+_chalk.default.gray("watching")+" "+_chalk.default.cyan(a);return(b?(b=normalize(b),d+="\n    "+_chalk.default.gray("as a dependency of")+" ",d+=_chalk.default.cyan(b)):b=a,watchList[a])?-1===watchList[a].indexOf(b)?(consoleLog(d),void watchList[a].push(b)):void 0:void(consoleLog(d),watchList[a]=[b],_fs.default.watchFile(a,{persistent:!0,interval:200},function(b,d){// File doesn't exist anymore. Keep watching.
0===b.mtime.getTime()||b.mtime.getTime()===d.mtime.getTime()||watchList[a].forEach(function(a){tryRender(a,c)})}))}/**
 * Convert error to string
 */function errorToString(a){return a.stack||(/* istanbul ignore next */a.message||a)}/**
 * Try to render `path`; if an exception is thrown it is printed to stderr and
 * otherwise ignored.
 *
 * This is used in watch mode.
 */function tryRender(a,b){try{renderFile(a,b)}catch(a){// keep watching when error occured.
console.error(errorToString(a)+"\x07")}}// Compile from stdin
function stdin(){let a="";process.stdin.setEncoding("utf8"),process.stdin.on("data",function(b){a+=b}),process.stdin.on("end",function(){let b;if(options.client)b=_pug.default.compileClient(a,options);else{let b=_pug.default.compile(a,options),c=b(options)}process.stdout.write(b)}).resume()}// Process the given path, compiling the pug files found.
function renderFile(a,b){const c=/\.(?:pug|jade)$/;let d=_fs.default.lstatSync(a);// Found pug file
if(d.isFile()&&c.test(a)&&!/([\/\\]_)|(^_)/.test(a)){_commander.program.watch&&watchFile(a,null,b),_commander.program.nameAfterFile&&(options.name=getNameFromFileName(a));var e=options.client?_pug.default.compileFileClient(a,options):_pug.default.compileFile(a,options);_commander.program.watch&&e.dependencies&&e.dependencies.forEach(function(c){watchFile(c,a,b)});// --extension
var f;f=_commander.program.extension?"."+_commander.program.extension:options.client?".js":""===_commander.program.extension?"":".html",a=a.replace(c,f),_commander.program.out&&(a=b?relative(b,a):basename(a),a=resolve(_commander.program.out,a));var g=resolve(dirname(a));_mkdirp.mkdirp.sync(g);var h=options.client?e:e(options);_fs.default.writeFileSync(a,h),consoleLog("  "+_chalk.default.gray("rendered")+" "+_chalk.default.cyan("%s"),normalize(a))}else if(d.isDirectory()){var i=_fs.default.readdirSync(a);i.map(function(b){return a+"/"+b}).forEach(function(c){render(c,b||a)})}}function getNameFromFileName(a){let b=basename(a).replace(/\.(?:pug|jade)$/,"");return b.toLowerCase().replace(/[^a-z0-9]+([a-z])/g,function(a,b){return b.toUpperCase()})+"Template"}